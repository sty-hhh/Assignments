     	.data
X:   	.word   268435455
Y:  	.word   268435455
        .text
main:
	lw	$a0,X			# $a0代表被乘数的低32位
	lw	$a1,Y			# $a1代表乘数
	addi	$a2,$0,0		# $a2代表被乘数的高32位
	addi 	$v0,$0,0		# $v0代表积的高32位
	addi   	$v1,$0,0		# $v1代表积的低32位
	addi	$s0,$0,32		# $s0代表循环次数	
loop:
	andi	$t0,$a1,1		# 如果乘数最低位是1，$t0 = 1
	beq	$t0,$0,then		# 乘数最低位是0，跳转到then
					# 乘数最低位是1，那么...		
	addu 	$v1,$a0,$v1		# 积的低32位 = 被乘数低32位 + 积的低32位
	sltu 	$t0,$v1,$a0		# 如果积的低32位 < 被乘数低32位，说明发生进位，要向高位进1
	addu 	$v0,$v0,$t0		# 积的高32位 = 积的高32位 + 进位
	addu 	$v0,$v0,$a2		# 积的高32位 = 积的高32位 + 被乘数的高32位	
then:	
	srl  	$a1,$a1,1		# 乘数右移一位
	sll	$a2,$a2,1		# 被乘数高32位左移一位
	andi	$t0,$a0,0x80000000	# 如果被乘数低32位的最高位是1，$t0 = 1
	sll	$a0,$a0,1		# 被乘数低32位左移一位
	beq	$t0,$0,L		# 如果被乘数低32位的最高位是0，即$t0 = 0,跳转到L
	ori	$a2,$a2,1		# 如果被乘数低32位的最高位是1，被乘数高32位的最低位 置1
L:	
	addi	$s0,$s0,-1		# 循环次数减1
	beq	$s0,$0,final		# 如果循环32次，跳转到final
	j	loop			# 未循环32次，跳转到loop，继续循环
final:
	addu	$a0,$v0,$0		# 输出积的高32位
	li	$v0,35			# 输出二进制
	syscall
	addu	$a0,$v1,$0		# 输出积的低32位
	li	$v0,35			# 输出二进制
	syscall
	li	$v0,10			# 程序结束
	syscall
